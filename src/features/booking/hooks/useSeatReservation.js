// src/features/booking/hooks/useSeatReservation.js

import { useState, useEffect, useRef, useCallback } from 'react';
import {
    reserveSeat,
    releaseSeat,
    fetchAllSeatStatus,
} from '../services/bookingService';
import {
    getPollingInterval,
    isBackendPollingSupported,
    pollSeatStatus,
    createStablePollingManager,
} from '../services/seatService';
import apiClient from '../../../shared/utils/apiClient';

export const useSeatReservation = (concertId, options = {}) => {
    const { enablePolling = true } = options;
    // 1. Î™®Îì† Í¥ÄÎ†® ÏÉÅÌÉúÎäî ÌõÖ ÎÇ¥ÏóêÏÑúÎßå Í¥ÄÎ¶¨Ìï©ÎãàÎã§.
    const [seatStatuses, setSeatStatuses] = useState([]);
    const [selectedSeats, setSelectedSeats] = useState([]);
    const [isReserving, setIsReserving] = useState(false);
    const [error, setError] = useState(null);
    const [timer, setTimer] = useState(0);
    const [isPolling, setIsPolling] = useState(false);
    const [connectionStatus, setConnectionStatus] = useState('disconnected'); // 'disconnected', 'connecting', 'connected', 'error'

    const selectedSeatsRef = useRef(selectedSeats);
    const pollingManagerRef = useRef(null);
    const stablePollingManagerRef = useRef(null);
    const isStartingPollingRef = useRef(false);

    useEffect(() => {
        selectedSeatsRef.current = selectedSeats;
    }, [selectedSeats]);

    const MAX_SEATS_SELECTABLE = 2;

    // 2. Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® Ìï®ÏàòÎ•º ÌõÖ ÎÇ¥Î∂ÄÏóê Ï†ïÏùòÌï©ÎãàÎã§.
    const refreshSeatStatuses = useCallback(async () => {
        try {
            const data = await fetchAllSeatStatus(concertId);
            setSeatStatuses(data);
            const myReservedSeats = data.filter(
                (s) => s.isReservedByCurrentUser,
            );
            setSelectedSeats(myReservedSeats);
        } catch (err) {
            setError(err.message || 'Ï¢åÏÑù Ï†ïÎ≥¥Î•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
        }
    }, [concertId]);

    // Ìè¥ÎßÅ ÏãúÏä§ÌÖú ÏãúÏûë Ìï®Ïàò
    const startPolling = useCallback(async () => {
        // Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ
        if (isStartingPollingRef.current || isPolling || !enablePolling) {
            return;
        }

        // ÏãúÏûë ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
        isStartingPollingRef.current = true;

        try {
            // Í∏∞Ï°¥ Ìè¥ÎßÅ ÏÑ∏ÏÖò Ï†ïÎ¶¨
            if (stablePollingManagerRef.current) {
                stablePollingManagerRef.current.stop();
                stablePollingManagerRef.current = null;
            }
            if (pollingManagerRef.current) {
                pollingManagerRef.current = null;
            }

            setIsPolling(true);
            setConnectionStatus('connecting');

            // Îã®Ïàú Ï£ºÍ∏∞Ï†Å Ìè¥ÎßÅ ÏãúÏä§ÌÖú ÏÇ¨Ïö©
            if (isBackendPollingSupported()) {
                console.log('üî• Ìè¥ÎßÅ ÏãúÏä§ÌÖú ÏãúÏûë (35Ï¥à Í∞ÑÍ≤©)');

                // Ìè¥ÎßÅ Îß§ÎãàÏ†Ä ÏÉùÏÑ±
                const stableManager = createStablePollingManager(concertId, {
                    onUpdate: (seatUpdates) => {
                        console.log('üî• Ï¢åÏÑù ÏóÖÎç∞Ïù¥Ìä∏ ÏàòÏã†:', seatUpdates);
                        refreshSeatStatuses();
                    },
                    onError: (error) => {
                        console.error('üî• Ìè¥ÎßÅ ÏóêÎü¨:', error);
                        setError(error.message);
                        setConnectionStatus('error');
                    },
                    onStatusChange: (isConnected) => {
                        setConnectionStatus(
                            isConnected ? 'connected' : 'disconnected',
                        );
                    },
                });

                stablePollingManagerRef.current = stableManager;
                stableManager.start();

                pollingManagerRef.current = {
                    stopPolling: () => {
                        stableManager.stop();
                        setIsPolling(false);
                        setConnectionStatus('disconnected');
                    },
                };
            } else {
                // Ìè¥Î∞±: ÏùºÎ∞ò Ï£ºÍ∏∞Ï†Å ÏÉàÎ°úÍ≥†Ïπ®
                console.log(
                    'üî• Î∞±ÏóîÎìú Long Polling ÎπÑÌôúÏÑ±Ìôî - ÏùºÎ∞ò Ï£ºÍ∏∞Ï†Å ÏÉàÎ°úÍ≥†Ïπ® Î™®Îìú',
                );

                const pollingInterval = getPollingInterval();
                console.log(
                    `üî• ${pollingInterval / 1000}Ï¥à Ï£ºÍ∏∞ Ï¢åÏÑù ÏÉÅÌÉú ÏÉàÎ°úÍ≥†Ïπ® ÏãúÏä§ÌÖú ÏãúÏûë`,
                );

                // Ìè¥ÎßÅ Í¥ÄÎ¶¨ Í∞ùÏ≤¥ Ï†ÄÏû• (Î®ºÏ†Ä ÏÑ§Ï†ï)
                pollingManagerRef.current = {
                    stopPolling: () => {
                        setIsPolling(false);
                        setConnectionStatus('disconnected');
                    },
                };

                // Ï¶âÏãú Ìïú Î≤à Ïã§Ìñâ
                await executePollingCycle();

                // Ìè¥ÎßÅ ÏÇ¨Ïù¥ÌÅ¥ÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ïã§ÌñâÌïòÎäî Ìï®Ïàò
                const runPollingLoop = async () => {
                    let cycleCount = 0;
                    while (isPolling && enablePolling) {
                        cycleCount++;
                        console.log(`üî• Ìè¥ÎßÅ ÏÇ¨Ïù¥ÌÅ¥ #${cycleCount} ÎåÄÍ∏∞ Ï§ë...`);

                        // Îã§Ïùå Ìè¥ÎßÅÍπåÏßÄ ÏÑ§Ï†ïÎêú Í∞ÑÍ≤© ÎåÄÍ∏∞
                        const pollingInterval = getPollingInterval();
                        await new Promise((resolve) =>
                            setTimeout(resolve, pollingInterval),
                        );

                        // ÏÉÅÌÉú Ïû¨ÌôïÏù∏
                        if (!isPolling || !enablePolling) {
                            console.log('üî• Ìè¥ÎßÅ Î£®ÌîÑ Ï§ëÎã®:', {
                                isPolling,
                                enablePolling,
                            });
                            break;
                        }

                        await executePollingCycle();
                    }
                    console.log('üî• Ìè¥ÎßÅ Î£®ÌîÑ Ï¢ÖÎ£å');
                };

                // Ìè¥ÎßÅ Î£®ÌîÑ ÏãúÏûë (ÎπÑÎèôÍ∏∞)
                runPollingLoop();
            }

            setConnectionStatus('connected');
        } finally {
            // ÏãúÏûë ÌîåÎûòÍ∑∏ Ìï¥Ï†ú
            isStartingPollingRef.current = false;
        }
    }, [concertId, isPolling, enablePolling, refreshSeatStatuses]);

    // Ìè¥ÎßÅ ÏÇ¨Ïù¥ÌÅ¥ Ïã§Ìñâ Ìï®Ïàò (Ìè¥Î∞±Ïö© - ÏùºÎ∞ò ÏÉàÎ°úÍ≥†Ïπ® Î™®Îìú)
    const executePollingCycle = useCallback(async () => {
        try {
            console.log('üî• Ï¢åÏÑù ÏÉÅÌÉú ÏÉàÎ°úÍ≥†Ïπ® ÏÇ¨Ïù¥ÌÅ¥ ÏãúÏûë');

            // refreshSeatStatuses Ìò∏Ï∂ú (Ïã§ÏãúÍ∞Ñ Ï¢åÏÑù ÏÉÅÌÉú ÎèôÍ∏∞Ìôî)
            console.log('üî• refreshSeatStatuses Ìò∏Ï∂ú');
            await refreshSeatStatuses();

            setError(null);
            setConnectionStatus('connected');
        } catch (error) {
            console.error('üî• Ìè¥ÎßÅ ÏÇ¨Ïù¥ÌÅ¥ ÏóêÎü¨:', error);
            setError(error.message);
            setConnectionStatus('error');
        }
    }, [concertId, refreshSeatStatuses]);

    // Ìè¥ÎßÅ ÏãúÏä§ÌÖú Ï†ïÏßÄ Ìï®Ïàò
    const stopPolling = useCallback(() => {
        console.log('üî• Ìè¥ÎßÅ ÏãúÏä§ÌÖú Ï§ëÏßÄ');
        setIsPolling(false);
        setConnectionStatus('disconnected');

        // ÏãúÏûë ÌîåÎûòÍ∑∏ÎèÑ Ìï¥Ï†ú
        isStartingPollingRef.current = false;

        // ÏïàÏ†ïÏ†ÅÏù∏ Ìè¥ÎßÅ Îß§ÎãàÏ†Ä Ï†ïÎ¶¨
        if (stablePollingManagerRef.current) {
            stablePollingManagerRef.current.stop();
            stablePollingManagerRef.current = null;
        }

        pollingManagerRef.current = null;
    }, []);

    // ÌÉÄÏù¥Î®∏ Î°úÏßÅ (Ïù¥Ï†ÑÍ≥º ÎèôÏùº)
    useEffect(() => {
        if (selectedSeats.length > 0 && timer === 0) {
            const minSeconds = Math.min(
                ...selectedSeats.map((s) => s.remainingSeconds),
            );
            setTimer(minSeconds > 0 ? minSeconds : 0);
        } else if (selectedSeats.length === 0) {
            setTimer(0);
        }
    }, [selectedSeats]);

    useEffect(() => {
        if (timer <= 0) {
            if (selectedSeatsRef.current.length > 0) {
                alert('ÏÑ†Ï†ê ÏãúÍ∞ÑÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§.');
                handleClearSelection().catch(console.error);
            }
            return;
        }
        const interval = setInterval(() => setTimer((prev) => prev - 1), 1000);
        return () => clearInterval(interval);
    }, [timer]);

    // Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï¢åÏÑù Ìï¥Ï†ú Î∞è Ìè¥ÎßÅ Ï†ïÎ¶¨
    useEffect(() => {
        return () => {
            // Ìè¥ÎßÅ Ï†ïÎ¶¨
            if (stablePollingManagerRef.current) {
                stablePollingManagerRef.current.stop();
            }
            if (pollingManagerRef.current) {
                pollingManagerRef.current.stopPolling();
            }

            // Ï¢åÏÑù Ìï¥Ï†ú
            if (selectedSeatsRef.current.length > 0) {
                selectedSeatsRef.current.forEach((seat) => {
                    releaseSeat(concertId, seat.seatId).catch(console.error);
                });
            }
        };
    }, [concertId]);

    // 3. Î™®Îì† Ìï∏Îì§Îü¨ Ìï®ÏàòÎ•º ÌõÖ ÎÇ¥Î∂ÄÏóê Ï†ïÏùòÌï©ÎãàÎã§.
    const handleSeatClick = useCallback(
        async (seat) => {
            setIsReserving(true);
            setError(null);
            try {
                const isSelected = selectedSeats.some(
                    (s) => s.seatId === seat.seatId,
                );
                if (isSelected) {
                    await releaseSeat(concertId, seat.seatId);
                } else {
                    if (seat.status !== 'AVAILABLE')
                        throw new Error('ÏÑ†ÌÉù Î∂àÍ∞Ä Ï¢åÏÑù');
                    if (selectedSeats.length >= MAX_SEATS_SELECTABLE)
                        throw new Error(
                            `ÏµúÎåÄ ${MAX_SEATS_SELECTABLE}ÏÑù ÏÑ†ÌÉù Í∞ÄÎä•`,
                        );
                    await reserveSeat(concertId, seat.seatId);
                }
                await refreshSeatStatuses(); // ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
            } catch (err) {
                setError(err.message);
            } finally {
                setIsReserving(false);
            }
        },
        [concertId, selectedSeats, refreshSeatStatuses],
    );

    const handleClearSelection = useCallback(async () => {
        setIsReserving(true);
        try {
            await Promise.all(
                selectedSeats.map((seat) =>
                    releaseSeat(concertId, seat.seatId),
                ),
            );
            await refreshSeatStatuses();
        } catch (err) {
            setError(err.message);
        } finally {
            setIsReserving(false);
        }
    }, [concertId, selectedSeats, refreshSeatStatuses]);

    const handleRemoveSeat = useCallback(
        (seatId) => {
            const seatToRemove = selectedSeats.find((s) => s.seatId === seatId);
            if (seatToRemove)
                handleSeatClick(seatToRemove).catch(console.error);
        },
        [selectedSeats, handleSeatClick],
    );

    // Ï¢åÏÑù Î≥µÍµ¨ ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Ìï®Ïàò
    const handleRestoreComplete = useCallback(async () => {
        try {
            // Î®ºÏ†Ä ÏÉÅÌÉúÎ•º ÏôÑÏ†ÑÌûà Ï¥àÍ∏∞Ìôî
            setSelectedSeats([]);
            setTimer(0);
            setError(null);

            // Í∑∏ Îã§Ïùå ÏÑúÎ≤Ñ ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
            await refreshSeatStatuses();

            console.log('Ï¢åÏÑù Î≥µÍµ¨ ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        } catch (err) {
            console.error('Ï¢åÏÑù Î≥µÍµ¨ ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', err);
            setError(err.message);
        }
    }, [refreshSeatStatuses]);

    // Ìè¥ÎßÅ ÏÉÅÌÉú Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const getPollingStatus = useCallback(() => {
        if (stablePollingManagerRef.current) {
            return stablePollingManagerRef.current.getStatus();
        }
        return {
            isPolling: isPolling,
            retryCount: 0,
            lastUpdateTime: null,
        };
    }, [isPolling]);

    // 4. ÌéòÏù¥ÏßÄÏóêÏÑú ÌïÑÏöîÌïú Î™®Îì† Í≤ÉÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
    return {
        seatStatuses,
        selectedSeats,
        isReserving,
        error,
        timer,
        isPolling,
        connectionStatus, // Ïó∞Í≤∞ ÏÉÅÌÉú: 'disconnected', 'connecting', 'connected', 'error'
        pollingStatus: getPollingStatus(), // Ìè¥ÎßÅ ÏÉÅÏÑ∏ ÏÉÅÌÉú
        refreshSeatStatuses, // ÌéòÏù¥ÏßÄÍ∞Ä ÏµúÏ¥à Î°úÎìú Ïãú Ìò∏Ï∂úÌï† Ìï®Ïàò
        startPolling, // Ìè¥ÎßÅ ÏãúÏä§ÌÖú ÏãúÏûë Ìï®Ïàò
        stopPolling, // Ìè¥ÎßÅ ÏãúÏä§ÌÖú Ï†ïÏßÄ Ìï®Ïàò
        handleSeatClick,
        handleRemoveSeat,
        handleClearSelection,
        handleRestoreComplete, // Ï¢åÏÑù Î≥µÍµ¨ ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Ìï®Ïàò
    };
};
